<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asteroids — SFX + UFOs (Single File)</title>
  <style>
    /* Minimal styling: fullscreen black canvas */
    html, body { height: 100%; margin: 0; background:#000; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    canvas { display:block; width:100%; height:100%; }
    #hud { position:fixed; left:12px; top:10px; color:#b9c1c8; font-size:14px; white-space:pre; user-select:none; pointer-events:none; }
    #center { position:fixed; inset:0; display:grid; place-items:center; color:#cfe8ff; font-size:18px; text-align:center; font-weight:600; }
  </style>
</head>
<body>
  <canvas id="screen"></canvas>
  <div id="hud"></div>
  <div id="center" style="display:none"></div>

  <script>
    // =============================
    // Asteroids — Full Basics + SFX + UFOs
    // - Turn, thrust, fire
    // - Wraparound
    // - Asteroids with jagged polygons
    // - Splitting (L->M->S)
    // - Collisions, score, lives, respawn with invuln
    // - UFO enemy with shots, hum, score value
    // - Basic WebAudio SFX (no external assets)
    // - R/Enter to restart
    // =============================

    // ---- Canvas / HiDPI ----
    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const centerMsg = document.getElementById('center');

    function resize() {
      const dpr = Math.max(1, Math.min(3, devicePixelRatio || 1));
      const w = innerWidth, h = innerHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w+'px'; canvas.style.height = h+'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    addEventListener('resize', resize); resize();

    // ---- Random helpers ----
    const rand = (a,b)=>a+Math.random()*(b-a);
    const choice = arr => arr[Math.floor(Math.random()*arr.length)];

    // ---- Starfield (static) ----
    const STAR_COUNT = 220;
    let stars=[];
    function seedStars(){
      stars=[]; for(let i=0;i<STAR_COUNT;i++) stars.push({x:Math.random()*innerWidth,y:Math.random()*innerHeight,r:Math.random()*1.2+0.2,a:Math.random()*0.5+0.5});
    }
    seedStars(); addEventListener('resize', seedStars);

    // ---- WebAudio SFX (pure synth, single context) ----
    // Uses tiny helpers for bleeps, noise bursts, looping oscillators for thrust and UFO hum.
    const SFX = (()=>{
      let ctx=null; // AudioContext
      let thrustNode=null; // {osc, gain}
      let ufoHumGain=null; // gain controlled hum, created lazily

      function ensure(){
        if (ctx) return ctx;
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return null;
        ctx = new AC();
        return ctx;
      }

      // Resume context on user gesture for autoplay policies.
      function resume(){ ensure(); if (ctx && ctx.state==='suspended') ctx.resume(); }

      // One-shot tone
      function tone(freq=440, dur=0.08, type='square', vol=0.12){
        if (!ensure()) return;
        const o=ctx.createOscillator();
        const g=ctx.createGain();
        o.type=type; o.frequency.value=freq;
        g.gain.value=vol;
        o.connect(g).connect(ctx.destination);
        const t=ctx.currentTime;
        // quick decay envelope
        g.gain.setValueAtTime(vol, t);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.start(t);
        o.stop(t+dur+0.02);
      }

      // Noise burst for explosions
      function noise(dur=0.35, vol=0.18){
        if (!ensure()) return;
        const length = Math.floor(ctx.sampleRate*dur);
        const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0;i<length;i++) data[i] = (Math.random()*2-1) * (1-i/length); // linear decay
        const src = ctx.createBufferSource(); src.buffer=buffer;
        const g = ctx.createGain(); g.gain.value=vol;
        // crude low-pass to make it less harsh
        const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1200;
        src.connect(lp).connect(g).connect(ctx.destination);
        const t=ctx.currentTime; src.start(t); src.stop(t+dur+0.02);
      }

      // Thrust continuous loop: start/stop
      function thrustStart(){
        if (!ensure()) return;
        if (thrustNode) return; // already running
        const osc = ctx.createOscillator(); osc.type='sawtooth'; osc.frequency.value=110;
        const g = ctx.createGain(); g.gain.value=0.0;
        // slightly modulate for a chugging engine feel
        const lfo = ctx.createOscillator(); lfo.frequency.value=6;
        const lfoGain = ctx.createGain(); lfoGain.gain.value=30; lfo.connect(lfoGain).connect(osc.frequency);
        osc.connect(g).connect(ctx.destination);
        const t=ctx.currentTime; g.gain.linearRampToValueAtTime(0.12, t+0.08);
        osc.start(); lfo.start();
        thrustNode = {osc, g, lfo};
      }
      function thrustStop(){
        if (!thrustNode || !ctx) return;
        const t=ctx.currentTime;
        thrustNode.g.gain.cancelScheduledValues(t);
        thrustNode.g.gain.setTargetAtTime(0.0001, t, 0.06);
        setTimeout(()=>{ try{ thrustNode.osc.stop(); thrustNode.lfo.stop(); }catch{} thrustNode=null; }, 120);
      }

      // UFO hum: keep alive while any UFO exists
      function ufoHumStart(){
        if (!ensure()) return;
        if (ufoHumGain) { // bring up if faded out
          const t=ctx.currentTime; ufoHumGain.gain.cancelScheduledValues(t); ufoHumGain.gain.linearRampToValueAtTime(0.15, t+0.2); return;
        }
        const osc = ctx.createOscillator(); osc.type='triangle'; osc.frequency.value=440; // base hum
        // slow vibrato
        const lfo = ctx.createOscillator(); lfo.frequency.value=5;
        const lfoGain = ctx.createGain(); lfoGain.gain.value=20; lfo.connect(lfoGain).connect(osc.frequency);
        const g = ctx.createGain(); g.gain.value=0.0;
        osc.connect(g).connect(ctx.destination);
        const t=ctx.currentTime; g.gain.linearRampToValueAtTime(0.15, t+0.25);
        osc.start(); lfo.start();
        ufoHumGain = g;
        ufoHumGain._osc = osc; ufoHumGain._lfo = lfo;
      }
      function ufoHumStop(){
        if (!ufoHumGain || !ctx) return;
        const t=ctx.currentTime; ufoHumGain.gain.linearRampToValueAtTime(0.0001, t+0.25);
        setTimeout(()=>{ try{ ufoHumGain._osc.stop(); ufoHumGain._lfo.stop(); }catch{} ufoHumGain=null; }, 400);
      }

      return {
        resume,
        shot: ()=>tone(900, 0.05, 'square', 0.10),
        ufoShot: ()=>tone(700, 0.07, 'square', 0.12),
        thrustStart, thrustStop,
        explode: ()=>{ noise(0.35, 0.20); tone(140, 0.12, 'sawtooth', 0.10); },
        smallExplode: ()=>{ noise(0.22, 0.15); tone(220, 0.08, 'square', 0.08); },
        ufoHumStart, ufoHumStop
      };
    })();

    addEventListener('pointerdown', SFX.resume, {once:false});
    addEventListener('keydown', SFX.resume, {once:false});

    // ---- Game state ----
    const bullets=[]; // player bullets {x,y,vx,vy,age}
    const enemyBullets=[]; // UFO bullets {x,y,vx,vy,age}
    const particles=[]; // explosions {x,y,vx,vy,age,life}
    let asteroids=[]; // {x,y,vx,vy,angle,spin,size,rad,verts}
    let ufos=[]; // {x,y,vx,vy,size,rad,shootT,dirT,value}

    const BULLET_SPEED=520, BULLET_LIFE=0.9, FIRE_DELAY=0.12, BULLET_LIMIT=5;
    const ENEMY_BULLET_SPEED=360, ENEMY_BULLET_LIFE=1.6, ENEMY_FIRE_DELAY=[1.6, 0.9]; // big / small UFO
    const SHIP_RAD = 12; // collision radius approximation

    const ship = {
      x: innerWidth/2, y: innerHeight/2,
      vx: 0, vy: 0,
      angle: 0,
      size: 18,
      turnSpeed: Math.PI,    // rad/s
      thrust: 220,           // px/s^2
      maxSpeed: 420,
      damping: 0.992,
      invuln: 0,             // seconds of invulnerability
      lastShot: 0
    };

    const game = { score:0, lives:3, wave:1, over:false, time:0, nextUfo: 8 }; // nextUfo counts down in seconds

    // ---- Input ----
    const keys = new Set();
    addEventListener('keydown', e=>{
      if (["ArrowLeft","ArrowRight","ArrowUp"," ","Enter","r","R"].includes(e.key)) e.preventDefault();
      keys.add(e.key.toLowerCase());
      if ((e.key==='r' || e.key==='R' || e.key==='Enter') && game.over) startGame();
    });
    addEventListener('keyup', e=>keys.delete(e.key.toLowerCase()));

    // ---- Asteroids ----
    function makeAsteroid(size, x, y){
      // size: 3=L,2=M,1=S
      const speed = rand(30, 70) * (4-size); // smaller -> faster
      const ang = rand(0, Math.PI*2);
      const vx = Math.cos(ang)*speed, vy=Math.sin(ang)*speed;
      const rad = size===3? 46 : size===2? 28 : 16;
      // Build jagged polygon vertices
      const verts=[]; const n = 10 + Math.floor(Math.random()*5);
      for(let i=0;i<n;i++){
        const a = (i/n)*Math.PI*2 + rand(-0.1,0.1);
        const r = rad * rand(0.75, 1.15);
        verts.push({a, r});
      }
      return {x,y,vx,vy,angle:rand(0,Math.PI*2), spin:rand(-1,1), size, rad, verts};
    }

    function spawnWave(){
      asteroids.length=0; ufos.length=0; enemyBullets.length=0; SFX.ufoHumStop();
      const count = 3 + game.wave; // increase per wave
      for(let i=0;i<count;i++){
        // spawn near edges, not near ship
        let x,y;
        do { x = choice([rand(0, innerWidth*0.1), rand(innerWidth*0.9, innerWidth)]);
             y = rand(0, innerHeight); } while (Math.hypot(x-ship.x,y-ship.y) < 200);
        asteroids.push(makeAsteroid(3, x, y));
      }
      // schedule UFO a bit sooner on higher waves
      game.nextUfo = rand(Math.max(5, 8 - game.wave*0.4), Math.max(7, 12 - game.wave*0.5));
    }

    function splitAsteroid(a){
      // scoring
      game.score += a.size===3? 20 : a.size===2? 50 : 100;
      // particles explosion
      for(let i=0;i<10;i++) particles.push({x:a.x,y:a.y,vx:rand(-80,80),vy:rand(-80,80),age:0,life:0.5});
      // sfx
      if (a.size===1) SFX.smallExplode(); else SFX.explode();
      if (a.size>1){
        // spawn two smaller
        for(let i=0;i<2;i++){
          const child = makeAsteroid(a.size-1, a.x, a.y);
          // inherit some of the parent's momentum
          child.vx += a.vx*0.2; child.vy += a.vy*0.2;
          asteroids.push(child);
        }
      }
    }

    // ---- UFOs ----
    function spawnUfo(){
      // Two types: big (value 200), small (value 1000). Small is faster + shoots more often.
      const small = Math.random() < Math.min(0.15 + game.wave*0.05, 0.6);
      const size = small ? 14 : 22; // render size and hit radius proxy
      const value = small ? 1000 : 200;
      const side = Math.random() < 0.5 ? 'left' : 'right';
      const y = rand(60, innerHeight-60);
      const x = (side==='left') ? -40 : innerWidth+40;
      const vx = (side==='left') ? rand(70, 120) : rand(-120, -70);
      const vy = rand(-35, 35);
      ufos.push({x,y,vx,vy,size,rad:size,shootT: rand(0.3, small? 0.9:1.6), dirT:0, value, small});
      SFX.ufoHumStart();
    }

    function ufoShoot(u){
      // Aim roughly at the ship with some error (smaller UFO = better aim)
      const dx = ship.x - u.x, dy = ship.y - u.y;
      let ang = Math.atan2(dy, dx);
      const spread = u.small ? 0.06 : 0.22; // accuracy
      ang += rand(-spread, spread);
      const vx = Math.cos(ang)*ENEMY_BULLET_SPEED;
      const vy = Math.sin(ang)*ENEMY_BULLET_SPEED;
      enemyBullets.push({x:u.x, y:u.y, vx, vy, age:0});
      SFX.ufoShot();
    }

    // ---- Game control ----
    function startGame(){
      // reset ship
      ship.x=innerWidth/2; ship.y=innerHeight/2; ship.vx=0; ship.vy=0; ship.angle=0; ship.invuln=2.5; ship.lastShot=0;
      // reset game
      bullets.length=0; enemyBullets.length=0; particles.length=0; ufos.length=0; asteroids.length=0;
      game.score=0; game.lives=3; game.wave=1; game.over=false; game.time=0; game.nextUfo=8; SFX.ufoHumStop();
      centerMsg.style.display='none';
      spawnWave();
    }

    function loseLife(){
      game.lives--;
      for(let i=0;i<16;i++) particles.push({x:ship.x,y:ship.y,vx:rand(-160,160),vy:rand(-160,160),age:0,life:0.7});
      SFX.explode();
      ship.x=innerWidth/2; ship.y=innerHeight/2; ship.vx=0; ship.vy=0; ship.angle=0; ship.invuln=2.5; bullets.length=0;
      if (game.lives < 0){
        game.over=true; SFX.ufoHumStop();
        centerMsg.innerHTML = `GAME OVER\nScore: ${game.score}\nPress R or Enter to restart`;
        centerMsg.style.display='grid';
      }
    }

    startGame();

    // ---- Main loop ----
    let last=performance.now();
    function loop(now){
      const dt = Math.min(0.05, (now-last)/1000); last=now; game.time += dt;
      update(dt, now);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ---- Update ----
    function update(dt, now){
      // Turning
      const left = keys.has('arrowleft') || keys.has('a');
      const right = keys.has('arrowright') || keys.has('d');
      if (left && !right) ship.angle -= ship.turnSpeed*dt;
      if (right && !left) ship.angle += ship.turnSpeed*dt;
      if (ship.angle > Math.PI) ship.angle -= Math.PI*2; else if (ship.angle < -Math.PI) ship.angle += Math.PI*2;

      // Thrust
      const thrusting = keys.has('arrowup') || keys.has('w');
      if (thrusting){ ship.vx += Math.cos(ship.angle)*ship.thrust*dt; ship.vy += Math.sin(ship.angle)*ship.thrust*dt; SFX.thrustStart(); }
      else SFX.thrustStop();
      ship.vx *= ship.damping; ship.vy *= ship.damping;
      const spd = Math.hypot(ship.vx, ship.vy);
      if (spd>ship.maxSpeed){ const s=ship.maxSpeed/spd; ship.vx*=s; ship.vy*=s; }

      // Integrate ship
      ship.x += ship.vx*dt; ship.y += ship.vy*dt;

      // Fire
      ship.lastShot += dt;
      const firing = keys.has(' ') || keys.has('space');
      if (firing && ship.lastShot >= FIRE_DELAY && bullets.length < BULLET_LIMIT){
        const nx = Math.cos(ship.angle), ny=Math.sin(ship.angle);
        bullets.push({ x: ship.x + nx*ship.size, y: ship.y + ny*ship.size, vx: nx*BULLET_SPEED + ship.vx*0.35, vy: ny*BULLET_SPEED + ship.vy*0.35, age:0 });
        ship.lastShot = 0; SFX.shot();
      }

      // Update bullets
      for (let i=bullets.length-1;i>=0;i--){
        const b=bullets[i]; b.x += b.vx*dt; b.y += b.vy*dt; b.age += dt; if (b.age > BULLET_LIFE) bullets.splice(i,1);
      }

      for (let i=enemyBullets.length-1;i>=0;i--){
        const b=enemyBullets[i]; b.x += b.vx*dt; b.y += b.vy*dt; b.age += dt; if (b.age > ENEMY_BULLET_LIFE) enemyBullets.splice(i,1);
      }

      // Update asteroids
      for (const a of asteroids){ a.x += a.vx*dt; a.y += a.vy*dt; a.angle += a.spin*dt*0.6; }

      // Update particles
      for (let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.age+=dt; if (p.age>p.life) particles.splice(i,1); }

      // Wrap everything
      wrap(ship); for (const b of bullets) wrap(b); for (const a of asteroids) wrap(a); for (const b of enemyBullets) wrap(b); for (const u of ufos) wrap(u);

      // Collisions: bullets vs asteroids
      for (let i=asteroids.length-1;i>=0;i--){
        const a = asteroids[i];
        let hit = -1;
        for (let j=bullets.length-1;j>=0;j--){
          const b = bullets[j];
          if (Math.hypot(b.x-a.x, b.y-a.y) < a.rad){ hit=j; break; }
        }
        if (hit>=0){ bullets.splice(hit,1); const dead = asteroids.splice(i,1)[0]; splitAsteroid(dead); }
      }

      // Collisions: ship vs asteroids
      if (ship.invuln>0) ship.invuln -= dt; else {
        for (const a of asteroids){ if (Math.hypot(ship.x-a.x, ship.y-a.y) < a.rad + SHIP_RAD){ loseLife(); break; } }
      }

      // UFO spawn timer
      if (!game.over){
        game.nextUfo -= dt;
        if (game.nextUfo <= 0){ spawnUfo(); game.nextUfo = rand(Math.max(6, 10 - game.wave*0.4), Math.max(9, 16 - game.wave*0.6)); }
      }

      // Update UFOs
      for (let i=ufos.length-1;i>=0;i--){
        const u = ufos[i];
        u.x += u.vx*dt; u.y += u.vy*dt; // movement
        u.dirT -= dt;
        // occasionally adjust vertical drift to wander
        if (u.dirT <= 0){ u.vy = rand(-50, 50); u.dirT = rand(1.2, 2.2); }
        // fire
        u.shootT -= dt;
        const fireDelay = u.small ? ENEMY_FIRE_DELAY[1] : ENEMY_FIRE_DELAY[0];
        if (u.shootT <= 0){ ufoShoot(u); u.shootT = fireDelay + rand(-0.2, 0.2); }
        // remove if far off-screen
        if (u.x < -80 || u.x > innerWidth+80) { ufos.splice(i,1); if (ufos.length===0) SFX.ufoHumStop(); }
      }

      // Collisions: player bullets vs UFOs
      for (let i=ufos.length-1;i>=0;i--){
        const u = ufos[i]; let hit=-1;
        for (let j=bullets.length-1;j>=0;j--){ const b=bullets[j]; if (Math.hypot(b.x-u.x,b.y-u.y) < u.rad){ hit=j; break; } }
        if (hit>=0){ bullets.splice(hit,1); ufos.splice(i,1); game.score += u.value; for(let k=0;k<20;k++) particles.push({x:u.x,y:u.y,vx:rand(-140,140),vy:rand(-140,140),age:0,life:0.45}); SFX.explode(); if (ufos.length===0) SFX.ufoHumStop(); }
      }

      // Collisions: enemy bullets vs ship
      if (ship.invuln<=0){
        for (let i=enemyBullets.length-1;i>=0;i--){ const b=enemyBullets[i]; if (Math.hypot(b.x-ship.x,b.y-ship.y) < SHIP_RAD){ enemyBullets.splice(i,1); loseLife(); break; } }
      }

      // Collisions: UFOs vs asteroids (optional small pushes)
      for (const u of ufos){ for (const a of asteroids){ if (Math.hypot(a.x-u.x,a.y-u.y) < a.rad + u.rad*0.8){ a.vx += (a.x-u.x)*0.2; a.vy += (a.y-u.y)*0.2; } } }

      // Wave clear -> next wave
      if (asteroids.length===0 && !game.over){ game.wave++; spawnWave(); }

      // HUD text
      hud.textContent = `Score: ${game.score}\nLives: ${Math.max(0, game.lives)}   Wave: ${game.wave}   UFOs: ${ufos.length}`;
    }

    // ---- Wrap helper ----
    function wrap(o){ const w=innerWidth, h=innerHeight; if (o.x<0) o.x+=w; else if (o.x>w) o.x-=w; if (o.y<0) o.y+=h; else if (o.y>h) o.y-=h; }

    // ---- Render ----
    function render(){
      const w=innerWidth, h=innerHeight;
      ctx.clearRect(0,0,w,h); ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);

      // stars
      for (const s of stars){ ctx.globalAlpha=s.a; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill(); }
      ctx.globalAlpha=1;

      // bullets
      ctx.fillStyle='#fff';
      for (const b of bullets){ ctx.globalAlpha=Math.max(0,1-b.age/BULLET_LIFE); ctx.beginPath(); ctx.arc(b.x,b.y,2,0,Math.PI*2); ctx.fill(); }
      ctx.fillStyle='#f8c5c5';
      for (const b of enemyBullets){ ctx.globalAlpha=Math.max(0,1-b.age/ENEMY_BULLET_LIFE); ctx.beginPath(); ctx.arc(b.x,b.y,2,0,Math.PI*2); ctx.fill(); }
      ctx.globalAlpha=1;

      // asteroids
      ctx.strokeStyle='#cfe8ff'; ctx.lineWidth=2; ctx.shadowColor='#cfe8ff'; ctx.shadowBlur=8;
      for (const a of asteroids){
        ctx.save(); ctx.translate(a.x,a.y); ctx.rotate(a.angle); ctx.beginPath();
        for (let i=0;i<a.verts.length;i++){
          const {a:ang,r} = a.verts[i]; const x=Math.cos(ang)*r, y=Math.sin(ang)*r; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath(); ctx.stroke(); ctx.restore();
      }
      ctx.shadowBlur=0;

      // ship
      ctx.save(); ctx.translate(ship.x, ship.y); ctx.rotate(ship.angle);
      const s = ship.size; ctx.beginPath(); ctx.moveTo(s,0); ctx.lineTo(-s*0.7,-s*0.8); ctx.lineTo(-s*0.4,0); ctx.lineTo(-s*0.7,s*0.8); ctx.closePath();
      ctx.lineWidth=2; ctx.strokeStyle= ship.invuln>0 && (Math.floor(performance.now()*0.01)%2===0) ? '#445' : '#8fd3ff';
      ctx.shadowColor='#8fd3ff'; ctx.shadowBlur= ship.invuln>0 ? 0 : 8; ctx.stroke();
      // flame
      const thrusting = keys.has('arrowup') || keys.has('w');
      if (thrusting){ ctx.beginPath(); ctx.moveTo(-s*0.7,-s*0.45); ctx.lineTo(-s*(0.7+0.45+Math.random()*0.15),0); ctx.lineTo(-s*0.7,s*0.45); ctx.closePath(); ctx.fillStyle='#ffb347'; ctx.shadowColor='#ffb347'; ctx.shadowBlur=12; ctx.fill(); }
      ctx.restore(); ctx.shadowBlur=0; ctx.globalAlpha=1;

      // UFOs
      for (const u of ufos){
        ctx.save(); ctx.translate(u.x,u.y);
        ctx.strokeStyle = u.small? '#ffbdbd' : '#f1f9a5';
        ctx.lineWidth=2; ctx.shadowColor=ctx.strokeStyle; ctx.shadowBlur=8;
        // simple saucer: two arcs + dome
        const r = u.size; ctx.beginPath(); ctx.ellipse(0,0,r*1.2,r*0.55,0,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(0,-r*0.35,r*0.45,Math.PI,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-r*0.9,0); ctx.lineTo(r*0.9,0); ctx.stroke();
        ctx.restore();
      }

      // particles
      ctx.fillStyle='#cfe8ff';
      for (const p of particles){ const a = Math.max(0, 1 - p.age/p.life); ctx.globalAlpha=a; ctx.fillRect(p.x, p.y, 2, 2); }
      ctx.globalAlpha=1;
    }

    addEventListener('pointerdown', ()=>window.focus());
  </script>
</body>
</html>
